import queue
import threading
import collections.abc

# source: https://stackoverflow.com/questions/9968592/turn-functions-with-a-callback-into-python-generators
class generator_from_callback(collections.abc.Generator):
    """
    A generator that is created from a callback function.

    Args:
        expr (function): A function that takes a callback.

    Raises:
        TypeError: If a non-None value is sent to a just-started generator.
        GeneratorExit: If the generator is closed.
        StopIteration: If the generator has reached the end.

    """
    def __init__(self, expr):
        """
        Initialize the generator.

        Args:
            expr (function): A function that takes a callback.

        """
        self._expr = expr
        self._done = False
        self._ready_queue = queue.Queue(1)
        self._done_queue = queue.Queue(1)
        self._done_holder = [False]

        # local to avoid reference cycles
        ready_queue = self._ready_queue
        done_queue = self._done_queue
        done_holder = self._done_holder

        def callback(value):
            """
            Callback function to process values received from the generator.

            Args:
                value: The value received from the generator.

            Raises:
                GeneratorExit: If the 'close' command is received.
                Exception: If the 'throw' command is received with an exception.

            Returns:
                Any: The value to be sent back to the generator.

            """
            done_queue.put((False, value))
            cmd, *args = ready_queue.get()
            if cmd == 'close':
                raise GeneratorExit
            elif cmd == 'send':
                return args[0]
            elif cmd == 'throw':
                raise args[0]

        def thread_func():
            """
            Thread function to execute the generator expression.

            Raises:
                GeneratorExit: If the 'close' command is received.
                Exception: If the 'throw' command is received with an exception.

            """
            try:
                cmd, *args = ready_queue.get()
                if cmd == 'close':
                    raise GeneratorExit
                elif cmd == 'send':
                    if args[0] is not None:
                        raise TypeError("can't send non-None value to a just-started generator")
                elif cmd == 'throw':
                    raise args[0]
                ret = expr(callback)
                raise StopIteration(ret)
            except BaseException as e:
                done_holder[0] = True
                done_queue.put((True, e))
        self._thread = threading.Thread(target=thread_func)
        self._thread.start()

    def __next__(self):
        """
        Get the next value from the generator.

        Returns:
            Any: The next value generated by the generator.

        Raises:
            StopIteration: If the generator has reached the end.

        """
        return self.send(None)

    def send(self, value):
        """
        Send a value to the generator.

        Args:
            value: The value to send to the generator.

        Returns:
            Any: The value generated by the generator.

        Raises:
            StopIteration: If the generator has reached the end.
            Exception: If an exception is raised during the generator execution.

        """
        if self._done_holder[0]:
            raise StopIteration
        self._ready_queue.put(('send', value))
        is_exception, val = self._done_queue.get()
        if is_exception:
            raise val
        else:
            return val

    def throw(self, exc):
        """
        Throw an exception into the generator.

        Args:
            exc (Exception): The exception to be thrown.

        Returns:
            Any: The value generated by the generator.

        Raises:
            StopIteration: If the generator has reached the end.
        """
        if self._done_holder[0]:
            raise StopIteration
        self._ready_queue.put(('throw', exc))
        is_exception, val = self._done_queue.get()
        if is_exception:
            raise val
        else:
            return val

    def close(self):
        """
        Close the generator.

        """
        if not self._done_holder[0]:
            self._ready_queue.put(('close',))
        self._thread.join()

    def __del__(self):
        """
        Clean up resources when the generator is deleted.

        """
        self.close()

